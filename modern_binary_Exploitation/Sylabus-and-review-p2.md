# Basic Memory Manipulation

```c

int i = 0;
char * message = "Hello World";
char * buffer = (char *)malloc(7)

if(buffer == NULL)
    return 1;
strncpy(buffer,message,5);
buffer[5] = '\n';
buffer[5] = '\0';

for (i = 0;i < 10; i++){
    printf("%s",buffer);
    free(buffer);
}

```

# Compile and Running it

```bash
 $gcc basic.c -o basic -std=gnu99
 $./basic

```

# what is your name
```c
#include <stdio.h>
#include <unistd.h>

int main(int argc,char * argv[]){
    char buffer[10] = {0};
    printf("What is your name ?\n");
    read(STDIN_FILENO,buffer,10);
    printf("Hello %s\n",buffer);
    return 0;
}

```
# Compile and Running it
```bash
 $gcc name.c -o name 
 $./name

```


# What's your name ? - 2.0
```c
#include <stdio.h>
#include <unistd.h>

int main(int argc,char * argv[]){
    char buffer[10] = {0};
    printf("What is your name ?\n");
    read(STDIN_FILENO,buffer,100);
    printf("Hello %s\n",buffer);
    return 0;
}

```

# Compile and Running it (Crash !)
```bash
 $gcc name.c -o name 
 $./name

```

# x86 Assembly

 - An assembly instruction set introduction in 1978 by intel
   - 1978 - 16bit
   - 1985 - 32bit
   - 2001 - 64bit (Itanium)
   - 2003 - 64bit (AMD64)
 - Overwrought CISC,a total playground for exploitation
  

# x86 Assembly Syntax

 - All assembly languages are made up of instruction sets
 - Instructions are generally simple arithmetic operations that take registers or constant values as arguments
   - Also called Operands,OpCode,Op(s),mnemonics
 - Intel syntax: operand destination,source
   - mov eax,5
 - AT&T syntax: operand source,destination
   - mov $5,eax
 - We'll be using the Intel syntax in this class
  

# Important Registers

 - ``` EAX,EBX,ECX,EDX ``` (General purpose register)
 - ``` ESP ``` (Stack pointer,"Top" of the current stack frame <Lower memory>)
 - ``` EBP ``` (Base Pointer,"bottom" of the current stack frame <higher memory>)
 - ``` EIP ``` (Instruction pointer,pointer to the next instruction to be executed by the CPU)
 - ``` EFLAGS ``` (Stores flag bits)
   - ``` ZF ``` (zero flag,set when result of an operating equals zero)
   - ``` CF ``` (Carry flag,set when the result of an operation is too large/small)
   - ``` SF ``` (Sign flag,when the result of an operation is negative)

# Moving Data
 - ``` mov ebx, eax ``` (Move the value in exa to ebx)
 - ``` mov eax,0xDEADBEEF ``` (Move 0xDEADBEEF into eax)
 - ``` mov edx,DWORD PTR [0x41424344]``` (Move the 4-byte value at address 0x41424344 into ecx )
 - ``` mov ecx,DWORD PTR [edx] ``` (Move the 4-byte value at the address in edx,into ecx) 
 - ``` mov eax,DWORD PTR [ecx+esi*8] ``` (Move the value at the address ecx+esi*8 into eax)


# Arithmetic Operations

 - ``` sub edx,0x11 ``` (edx = edx - 0x11)
 - ``` add eax,ebx ``` ( eax = eax + ebx)
 - ``` inc edx ``` (edx++)
 - ``` dec ebx ``` ( ebx--)
 - ``` xor eax,eax ``` ( eax= eax ^ eax)
 - ``` or edx,0x1337 ``` (edx = edx | 0x1337)

# Some Conditional Jumps

 - ```jz $LOC ``` (Jumps to $LOC if ZF = 1)
 - ```jnz $LOC ``` (Jumps to $LOC if ZF = 0)
 - ```jg $LOC ``` ( Jumps to $LOC if the result of a comparison is the destination is greater than the source )


# Stack Manipulation

 - ``` push ebx ``` (subtract 4 from the stack pointer to move it towards lower memory )
 - ``` pop ebx ``` (Copy the value off the top of the stack and into EBX)

# Calling / Returning

 - ``` call some_function ``` (Callls the code at some_function.we need to push the return address onto the stack,then branch to some_function)
 - ``` ret ``` (Used to return form a function call,pops the top of the stack to eip )
 - ``` nop ``` (no operation -does nothing) 

# Basic x86 
```
0x08048624: "YOLOSWAG\0"
  mov ebx,0x08048624
  mov eax,0
LOOPY:
  mov cl,BYTE PTR [ebx]
  cmp cl,0
  jz end
  inc eax
  inc ebx
  jmp LOOPY
end:
  ret
```